---
course_id: 6-005-software-construction-spring-2016
layout: course_section
menu:
  leftnav:
    identifier: 167cdf1148933281e566858683b999a4
    name: Readings
    weight: 30
title: Readings
type: course
uid: 167cdf1148933281e566858683b999a4

---

Example code for some readings can be found on the [6.005 Github page](https://github.com/mit6005/).

| Reading | Topics |
| --- | --- |
| [1: Static Checking](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/01-static-checking/) |  {{< br >}}{{< br >}} *   Types{{< br >}}*   Static Checking vs Dynamic Checking{{< br >}}*   Arrays and Collections{{< br >}}*   Iterating{{< br >}}*   Methods{{< br >}}*   Mutating Variables vs Reassigning Variables{{< br >}}*   Documenting Assumptions {{< br >}}{{< br >}}  |
| [2: Basic Java](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/02-basic-java/) |  {{< br >}}{{< br >}} *   Snapshot Diagrams{{< br >}}*   Java Collections{{< br >}}*   Java API Documentation {{< br >}}{{< br >}}  |
| [3: Testing](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/03-testing/) |  {{< br >}}{{< br >}} *   Validation{{< br >}}*   Test-first Programming{{< br >}}*   Choosing Test Cases by Partitioning{{< br >}}*   Blackbox and Whitebox Testing{{< br >}}*   Documenting Testing Strategies{{< br >}}*   Coverage{{< br >}}*   Unit Testing and Stubs{{< br >}}*   Automated Testing and Regression Testing {{< br >}}{{< br >}}  |
| [4: Code Review](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/04-code-review/) |  {{< br >}}{{< br >}} *   Don't Repeat Yourself{{< br >}}*   Comments Where Needed{{< br >}}*   Fail Fast{{< br >}}*   Avoid Magic Numbers{{< br >}}*   One Purpose for Each Variable{{< br >}}*   Use Good Names{{< br >}}*   Use Whitespace to Help the Reader{{< br >}}*   Don't Use Global Variables{{< br >}}*   Methods Should Return Results, Not Print Them {{< br >}}{{< br >}}  |
| [5: Version Control](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/05-version-control/) |  {{< br >}}{{< br >}} *   Inventing Version Control{{< br >}}*   Git: Copy, Commit, Pull, Push, Merge {{< br >}}{{< br >}}  |
| [6: Specifications](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/06-specifications/) |  {{< br >}}{{< br >}} *   Why Specifications?{{< br >}}*   Behavioral Equivalence{{< br >}}*   Specification Structure{{< br >}}*   Null References{{< br >}}*   What a Specification May Talk About{{< br >}}*   Testing and Specifications{{< br >}}*   Specifications for Mutating Methods{{< br >}}*   Exceptions for Signaling Bugs{{< br >}}*   Exceptions for Special Results{{< br >}}*   Checked and Unchecked Exceptions{{< br >}}*   Throwable Hierarchy{{< br >}}*   Exception Design Considerations{{< br >}}*   Abuse of Exceptions {{< br >}}{{< br >}}  |
| [7: Designing Specifications](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/07-designing-specs/) |  {{< br >}}{{< br >}} *   Deterministic vs Undertermined Specs{{< br >}}*   Declarative vs Operational Specs{{< br >}}*   Stronger vs Weaker Specs{{< br >}}*   Diagramming Specifications{{< br >}}*   Designing Good Specifications{{< br >}}*   Precondition or Postcondition?{{< br >}}*   About Access Control{{< br >}}*   About Static vs Instance Methods {{< br >}}{{< br >}}  |
| [8: Avoiding Debugging](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/08-avoiding-debugging/) |  {{< br >}}{{< br >}} *   First Defense: Making Bugs Impossible{{< br >}}*   Second Defense: Localizing Bugs{{< br >}}*   Assertions{{< br >}}*   What to Assert{{< br >}}*   What Not to Assert{{< br >}}*   Incremental Development{{< br >}}*   Modularity and Encapsulation {{< br >}}{{< br >}}  |
| [9: Mutability and Immutability](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/09-immutability/) |  {{< br >}}{{< br >}} *   Mutability{{< br >}}*   Risks of Mutation{{< br >}}*   Aliasing is What Makes Mutation Risky{{< br >}}*   Specifications for Mutating Methods{{< br >}}*   Iterating Over Arrays and Lists{{< br >}}*   Mutation Undermines an Iterator{{< br >}}*   Mutation and Contracts{{< br >}}*   Useful Implementation Types {{< br >}}{{< br >}}  |
| [10: Recursion](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/10-recursion/) |  {{< br >}}{{< br >}} *   Choosing the Right Decomposition For a Problem{{< br >}}*   Structure of Recursive Implementations{{< br >}}*   Helper Methods{{< br >}}*   Choosing the Right Recursive Subproblem{{< br >}}*   Recursive Problem vs Recursive Data{{< br >}}*   Reentrant Code{{< br >}}*   When to Use Recursion Rather Than Iteration{{< br >}}*   Common Mistakes in Recursive Implementations {{< br >}}{{< br >}}  |
| [11: Debugging](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/11-debugging/) |  {{< br >}}{{< br >}} *   Reproduce the Bug{{< br >}}*   Understand the Location and Cause of the Bug{{< br >}}*   Fix the Bug {{< br >}}{{< br >}}  |
| [12: Abstract Data Types](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/12-abstract-data-types/) |  {{< br >}}{{< br >}} *   What Abstraction Means{{< br >}}*   Classifying Types and Operations{{< br >}}*   Designing Abstract Type{{< br >}}*   Representation Independence{{< br >}}*   Realizing ADT Concepts in Java{{< br >}}*   Testing and Abstract Data Type {{< br >}}{{< br >}}  |
| [13: Abstraction Functions and Rep Invariants](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/13-abstraction-functions-rep-invariants/) |  {{< br >}}{{< br >}} *   Invariants{{< br >}}*   Rep Invariant and Abstraction Function{{< br >}}*   Documenting the AF, RI, and Safety from Rep Exposure{{< br >}}*   ADT Invariants Replace Preconditions {{< br >}}{{< br >}}  |
| [14: Interfaces](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/14-interfaces/) |  {{< br >}}{{< br >}} *   Interfaces{{< br >}}*   Subtypes{{< br >}}*   Example: MyString{{< br >}}*   Example: Set{{< br >}}*   Generic Interfaces{{< br >}}*   Why Interfaces?{{< br >}}*   Realizing ADT Concepts in Java, Part II {{< br >}}{{< br >}}  |
| [15: Equality](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/15-equality/) |  {{< br >}}{{< br >}} *   Three Ways to Regard Equality{{< br >}}*   \== vs. equals(){{< br >}}*   Equality of Immutable Types{{< br >}}*   The Object Contract{{< br >}}*   Equality of Mutable Types{{< br >}}*   The Final Rule for Equals() and hashCode() {{< br >}}{{< br >}}  |
| [16: Recursive Data Types](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/) |  {{< br >}}{{< br >}} *   Recursive Functions{{< br >}}*   Immutable Lists{{< br >}}*   Recursive Datatype Definitions{{< br >}}*   Functions Over Recursive Datatypes{{< br >}}*   Tuning the Rep{{< br >}}*   Null vs Empty{{< br >}}*   Declared Type vs Actual Type{{< br >}}*   Example: Boolean Formulas{{< br >}}*   Writing a Program with ADTs{{< br >}}*   Recipes for Programming with ADTs{{< br >}}*   Example: Matrix Multiplication {{< br >}}{{< br >}}  |
| [17: Regular Expressions and Grammars](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/17-regex-grammars/) |  {{< br >}}{{< br >}} *   Grammars{{< br >}}*   Regular Expressions {{< br >}}{{< br >}}  |
| [18: Parser Generators](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/18-parser-generators/) |  {{< br >}}{{< br >}} *   Parser Generators{{< br >}}*   An Antlr Grammar{{< br >}}*   Generating the Parser{{< br >}}*   Calling the Parser{{< br >}}*   Traversing the Parse Tree{{< br >}}*   Constructing an Abstract Syntax Tree{{< br >}}*   Handling Errors {{< br >}}{{< br >}}  |
| [19: Concurrency](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/19-concurrency/) |  {{< br >}}{{< br >}} *   Two Models for Concurrent Programming{{< br >}}*   Processes, Threads, Time-Slicing{{< br >}}*   Example: Shared Memory{{< br >}}*   Interleaving{{< br >}}*   Race Condition{{< br >}}*   Tweaking the Code Won't Help{{< br >}}*   Reordering{{< br >}}*   Example: Message Passing{{< br >}}*   Concurrency is Hard to Test and Debug {{< br >}}{{< br >}}  |
| [20: Thread Saftey](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/20-thread-safety/) |  {{< br >}}{{< br >}} *   What Threadsafe Means{{< br >}}*   Strategy 1: Confinement{{< br >}}*   Strategy 2: Immutability{{< br >}}*   Strategy 3: Using Threadsafe Data Types{{< br >}}*   How to Make A Safety Argument {{< br >}}{{< br >}}  |
| [21: Sockets and Networking](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/21-sockets-networking/) |  {{< br >}}{{< br >}} *   Client/Server Design Pattern{{< br >}}*   Network Sockets{{< br >}}*   I/O{{< br >}}*   Blocking{{< br >}}*   Using Network Sockets{{< br >}}*   Wire Protocols{{< br >}}*   Testing Client/Server Code {{< br >}}{{< br >}}  |
| [22: Queues and Message-Passing](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/22-queues/) |  {{< br >}}{{< br >}} *   Two Models for Concurrency{{< br >}}*   Message Passing with Threads{{< br >}}*   Implementing Message Passing with Queues{{< br >}}*   Stopping{{< br >}}*   Thread Safety Arguments with Message Passing {{< br >}}{{< br >}}  |
| [23: Locks and Synchronization](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/23-locks/) |  {{< br >}}{{< br >}} *   Synchronization{{< br >}}*   Deadlock{{< br >}}*   Developing a ThreadSafe Abstract Data Type{{< br >}}*   Locking{{< br >}}*   Monitor Pattern{{< br >}}*   Thread Safety Argument with Synchronization{{< br >}}*   Atomic Operations{{< br >}}*   Designing a Data Type for Concurrency{{< br >}}*   Deadlock Rears its Ugly Head{{< br >}}*   Goals of Concurrent Program Design{{< br >}}*   Concurrency in Practice {{< br >}}{{< br >}}  |
| [24: Graphical User Interfaces](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/24-graphical-user-interfaces/) |  {{< br >}}{{< br >}} *   View Tree{{< br >}}*   How the View Tree is Used{{< br >}}*   Input Handling{{< br >}}*   Separating Frontend from Backend{{< br >}}*   Background Processing in Graphical User Interfaces {{< br >}}{{< br >}}  |
| [25: Map, Filter, Reduce](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/25-map-filter-reduce/) |  {{< br >}}{{< br >}} *   Abstracting Out Control Flow{{< br >}}*   Map{{< br >}}*   Functions as Values{{< br >}}*   Filter{{< br >}}*   Reduce{{< br >}}*   Benefits of Abstracting Out Control{{< br >}}*   First-class Functions in Java{{< br >}}*   Map/Filter/Reduce in Java{{< br >}}*   Higher-order Functions in Java {{< br >}}{{< br >}}  |
| [26: Little Languages](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/26-little-languages/) |  {{< br >}}{{< br >}} *   Representing Code as Data{{< br >}}*   Building Languages to Solve Problems{{< br >}}*   Music Language {{< br >}}{{< br >}}  |
| [27: Team Version Control](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/27-team-version-control/) |  {{< br >}}{{< br >}} *   Git Workflow{{< br >}}*   Viewing Commit History{{< br >}}*   Graph of Commits{{< br >}}*   Using Version Control as a Team {{< br >}}{{< br >}}